#summary Политики безопасности системы
#labels Featured,Phase-Implementation,Phase-Design

== Обзор ==

Политика безопасности системы базируется на следующих основных положен

  # Безопасность пользовательских авторизационных сессий
  # Гарантия уровня безопасности инсталлируемых пакетов и модулей от сторонних поставщиков
  # Разделение прав доступа и полномочий пользователей системы


Основной функционал для управления авторизационными сессиями поставляется пакетом `*security*`, при этом обработка сессий на более низком уровне обеспечивается пакетом `*sessions*` (См. *Пользовательские сессии*). Методы для определения полномочий пользователя и создания политик безопасности, применяются методы пакета `*permissions*`.

Итак, основная составная часть общей политики безопасности любой системы - предоставращения какого-либо рода вмешательства со стороны третьих лиц в работу системы, либо попытки получить информацию, прав доступа к которой они не имеют.

Для этого вся система разбита на два логических раздела - Административный интерфейс и Пользовательский интерфейс.

Доступ ко всем без исключения (ну разве что исключением есть модуль "*Авторизация*") возможен лишь пользователю с правами администратора. При чём, в Пользовательском разделе так же существуют те разделы, к которым не все пользователи имеют доступ, а лишь некоторые, что так же следует учитывать.


== Профили доступа и разграничение прав ==

По сему, в системе введено понятие "*ПрофильПолномочий*". Далее следует пример объекта ПрофильПолномочий:
{{{
ПрофильПолномочий:{
   Идентификатор,
   Название
}
}}}
По сути говоря сам профиль представляет собой лишь указатель - ключ доступа, по которму будет определятся права пользователя.

Права доступа к тому либо иному модулю в отношении некоторого экземпляра объекта ПрофильПолномочий будет определять объект *ПолитикаБезопасности*, объект которой имеет следующую спецификацию:
{{{
ПолитикаБезопасности:{
   Идентификатор,
   Модуль,
   Раздел,
   ИдентификаторПрофиля,
   БлокировкаДоступа: (0,1,2)
}
}}}
То есть, общая политика безопасности для некоторого модуля, состоит из совокупности политик, которые определяют права пользователя на доступ к тому либо иному разделу некоторого модуля, в контексте профиля, на который указывает *ИдентификаторПрофиля*, с правами, декларируемыми в качестве с-ва *БлокировкаДоступа*.

Под блокировкой доступа подразумеваются фактические права пользоваля на доступ к указанному разделу данного модуля. Она может принимать следующие значения:
{{{
   0  -  доступ запрещён
   1  -  режим "только для чтения"
   2  -  режим "чтение+запись"
}}}
Если у данного профиля в контексте данного разделя модуля права установлены в значении "*только для чтения*", пользователь с таким профилем не имеет прав вносить какие-либо изменения в структуру данных, а только лишь ознакомиться с ними.

== Авторизация пользователей ==

Для удостоврения личности пользователя, в системе введён гибкий и надёжный механизм авторизации, который предоставляет пользователю следующие возможности удостоверения личности:

1.  Механизм Быстрой Процедуры Авторизации (*FAP*)
2.  Механизм Стандартной Процедуры Авторизации (*SPA*)
3.  Механизм Сертификата Безопасности (*SS*)

Итак, давайте рассмотрим стандартный случай обычной процедуры авторизации, во время которой пользователь указывает свой уникальный код, которые представляет собой *6-ти* циферное число, а так же прилагает специальным образом сформированый ключ. Успешность проверки данной связки будет свидетельствовать о том, что человек действительно является аутентичным пользователем системы, и что ему можно предоставить возможность получить доступ к модулям системы, к которым ему позволяет получить доступ его профиль полномочий.

После того, как пользователь прошёл авторизацию, на стороне севера создаётся сессия, привязанная к *IP*-адресу пользователя, которая будет доступна в течении *120 минут*, после чего пользователю вновь необходимо будет пройти процедуру авторизации, для подтверждения достоверности своей личности.

Однако пользователь по тем либо иным причинам мог выбрать нестандартный способ авторизации, и выбрать либо процедуру авторизации *SS* либо *FAP*.

Под процедурой *FAP* подразумевается возможность авторизации пользователя по уникальной ссылке действительной лишь для одной авторизации, после чего она изменяется в системе.

Для авторизации в системе по методу процедуры *FAP*, пользователь попросту переходит по ссылке, в которой присутствует особенный параметр, который определяет текущий уникальный ключ, по которому возможна быстрая авторизация. После перехода по данной ссылке, текущее значение ключа изменяется на новое, случайным образом сгенерированное, которое впоследствии отправляется пользовалю на его почтовый ящик.

Более интересна в качестве технологических особенностей технология *SS*, которая пока является лишь спецификацией, и не воплощена в практическом плане.

Суть данной процедуры авторизации, заключается в авторизации минуя браузер, а используя для отправки данных и авторизации определённое клиентское программное обеспечение.

Для использования протокола *SS*, пользователю достаточно обычной *Flash*-карты, либо диска, с установленной программой, а так же пользовательским сертификатом. После установки программы на носитель, она устанавливается в качестве приложения для автозапуска, и после прохождения процедуры подключения устройства к системе, программа запускатся, и если проверка вложенного сертификата прошла успешно, то для текущего IP пользователя создаётся новая сессия, которая как и прочие будет длится 120 минут, и позволит беспрепятственно работать с системой.

Сертификат представляет собой тот же ключ, который используется в контексте процедуры *FAP*, однако в данном случае пользователю нет потребности проходить процедуру авторизации на сайте, вместе чего просто запустить программу, либо вставить Flash-накопитель в *USB*-порт.


== Гарантия уровня безопасности инсталлируемых пакетов и модулей от сторонних поставщиков == 

{{{
  На данном этапе - исключительно на стадии проектировки и базовых наработок
}}}

Наиболее приоритетным для безопасности пользователей является вопрос об опасности нанесения их системе ущерба из-за использования ними недостоверных пакетов и модулей, которые могут содержать заведомо разрушительные указания серверу.

Для предотвращения подобной опасности, вводится протокол *3RDValidation*, который служит для проверки аутентичности пакетов, и каждой их составляющей.

Каждый разработчик может зарегистрировать свой пакет в репозитории проектов *InvisCore*, и получить уникальный *RegCode*, который будет идентифицировать их пакет/модуль.

Процедура валидации пакета состоит в вычислении суммарного хеш-кода (*MD5*-алгоритм) всех составных поставки стороннего вендора, и сравнении их в аналогичным значением на стороне сервера-источника *3RDValidation?. Проверка происходит в отношении записи с RegCode-значением и версией равнойм передаваемым данным на стороне сервера валидации.