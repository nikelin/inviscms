#labels Featured,Phase-Implementation,Phase-Design
= Обзор =

В процессе разработки системы, постепенно всё большей проблемой в плане быстродействия системы являлся факт излишней избыточности стандарта *XML-документа*, и довольно ресурсоёмкого процесса обработки и транслирования в структуру данных, ввиду чего было принято решение упростить стандарт, что и привело к возникновению формата *eXisity*.
(Прим. автора: в значительной степени повлияла идеология языка *Brainfuck* :) )


= Детали =

Для наглядности и осязаемости дальнейшего описания формата приведём сначала пример структуры формата *EST*:
`
-root <root:http://ns.com root2:http://ns2.com
  -roo2>a<n:http://g3.com n2:http://g4.com 
      -n2>b
           -c(a:24 b:52 c:sdaas24')-
              `
               Some inline
               data
                     with any sturcuture content
                what must ends by delimiter 
              `
               `
                Tag can have more then one data containers,
                 what will be concatenated after translation
              to one string
               `
      n2>b-
  root2>a-
root-
`


== Контейнер ==

Существует лишь один корневой элемент структуры, который не имеет элемента родителя, при этом все остальные элементы являются потомками элемента к которому они относятся.

Контейнер может быть представлен структурой двух типов: парным контейнером, и пустым контейнером. При этом *ПУСТЫМ* следует считать тот контейнер, который не имеет парного ему, закрывающего контейнера. В тоже время *ПАРНЫМ* считается всякий контейнер, который имеет парный закрыважющий контейнер.

Структура любого контейнера представлена следующими составными:
  # пространство имём, к которому принадлежит данный контейнер (*ОПЦИОНАЛЬНО*)
  # идентификатор данного контейнера, который служит для адресации к данному контейнеру
  # перечисление атрибутов данного контейнера (*ОПЦИОНАЛЬНО*)
  # перечисление (объявление) пространства имён, используемых в данном контейнере (*ОПЦИОНАЛЬНО*)
  # тело объекта (в случае *ПАРНОГО* контейнера), представленое в виде контейнеров-потомков, линейной структурой либо может быть опущеным (*ОПЦИОНАЛЬНО*)
  # закрывающий контейнер (в случае *ПАРНОГО* контейрнера), который имеет идентичный открывающему контернеру идентификатор, с указанием пространства имён
   
Формализированный синтаксис контейнера имеет следующую структуру:
`# Использовался PCRE-подбный синтаксис регулярных строк
  %пробел%:=[\s]+
  %идентификатор%:=([a-zA-Z]+[a-zA-Z0-9_]*)
  %число%:=([\-]?[0-9]+[0-9,E]*)
  %пространство-имён%:=((%идентификатор%)+[\>]+)
  %объявление-пространства-имён%:=([<]+(%идентификатор%+\:(%URI-адресс%)[%пробел])+)
  %атрибуты%:=(((%идентификатор%)+[\:]+(%строка% | %число%)+[\']+[%пробел%]+)+)
  %линейная-структура%=([\`][.]*[\`])
  %тело%:=(%пробел)+(%парный-контейнер%+|%пустой-контейнер%|%линейная-структура%)+(%пробел%)+
  %парный-контейнер%:=(%пространство-имён%)?(%идентификатор%)+[\-]+(%атрибуты%)?(%объявление-пространства-имён%)?(%тело%)*(%идентификатор%)[\-]+  
  %пустой-контейнер%:=[\-]+(%пространство-имён%)?(%идентификатор%)+(%атрибуты%)?(%объявление-пространства-имён%)?[\-]+
`

== Пространство имён ==

*Пространство имён* - абстрактное понятие, классифицирующее группу контейнеров, которые к нему относятся.
Объявляется в открывающем контейнере, в контексте которого и преобретает актуальность, а то есть появляется возможность адресации к его контексту.
По умолчанию, все элементы принадлежат к пространству имён корневого элемента, который в свою очеред представляет стандартное пространство имён. В свою очередь все потомки некоторого не корневого элемента наследуют его пространство имён, если иное не указанно явно.
К примеру:

`
-root 
  -a
  -a
  -b
  b-
  -a
  a-
root-
`

В данном случае, для элемента `*root:a*` - root будет будет пространством имён, и в свою очередь для `*root:a:a*`, пространством имён будет `root:a`.
Пространства имён используются для адрессации к элементам в пост-трансляционном массиве данных. К примеру, если указатель стоит на элементе `*root*`, то к его пространству '*\.*' будет относится элемент `*a*`, и аналогично далее.

== Идентификатор контейнера ==

Каждый контейнер представлен идентификатором, составленым связкой пространства имён, к которому он относится, а так же текстовым идентификатором, используемым для адресации к данному контейнеру в контексте пространства имён.
Идентификатор *НЕ ОБЯЗАТЕЛЬНО* должен быть уникальным. В случае, если в данном пространстве элементов, идентификатор не уникален, то в результирующую структуру войдёт массив элементов, состоящий из элементов, имеющих идентичный идентификатор.
Идентификатор может быть представлен сторокой любой длины, при чём первый символ идентификатора обязательно должен быть представлен символами в промежутке от *a* до *z* латиницы, и в *ОБЯЗАТЕЛЬНОМ* порядке иметь нижний регистр.

== Список атрибутов ==

Каждый контейнер может имет список атрибутов. Атрибуты представлены спискоком из n-элементов, разделённых пробелами вида "*идентификатор:значение*".
Формат идентификатора атрибута идентичен формату идентификатора контейнера.
Для разделения имени идентификатора от его значения, используется символ двоеточие (*":"*), после которого следует указание значения либо признак опущенного(*пустого*) значения - знак "*-*".

Значения атрибута может быть либо числом, либо строкой содержащией произвольные данные, завершающиейся признаком конца строка - символом "*`*".

Число в спецификации формата *EST* представлено ввиде комбинации цифр с опциональным наличием знака отрицательного значения - "*-*" (минус), признака вещественного числа (числа с плавающей точкой) - "*,*"(`запятая`), знака разделения десятков ("*.*"), а так же признака экспоненциальной формы числа - латинского символа "*e*" в верхнем регистре.

Список атрибутов контейнера начинается с левой округлой скобки, и завершается правой округлой скобкой. Атрибуты разделяются между собой одной либо более запятыми.

== Объявление пространств имён ==

Одно либо более пространство имён *МОЖЕТ* быть объявлено в структуре открывающего элемента *ПАРНОГО* контейнера, после указания идентификатора элемента.
Перечисление списка объявлений пространств имён начинается с открывающего символа "*<*" и завершается закрывающим символом "*>*".

Структура пространства имён представлена ввиде идентификатора пространства имён и *URI*-доменом пространства имён, которые отделяются символом двоеточие ("*:*"). Идентификатор имеет структуру идентичную идентификатору контейнера, а *URI*-домен, соответственно, специфицируется шаблоном *URI*-идентификаторов.

Пространства имён отделяются друг от друга символом *пробел*.

Более чем одно пространство имён не может относится к одному и тому же домену, при этом подобные пространства имён приводятся к одному.

== Указание пространства имён ==

Для указания пространства имён, к которому относится данный контейнер либо атрибут некоторого контейнера, в начале его идентификатора идёт указание идентификатора пространства имён, после указания которого следует служеюный символ "*>*".

При этом адресуемым считает пространство имён, которое объявлено в контексте некоторого элемента родителя по отношению к данному элементу.

Атрибуты не могут производить адресацию к пространству имён, которое объявлено в контексте данного контейнера.

== Семантика и синтаксис линейных структур ==

Под линейной структурой подразумевается некоторое содержимое произвольного формата, объявленное в контексте нкоторого *ПАРНОГО* модуля, в его теле.

Линейная структура начинается открывающим символом тильда ("*`*") и им же закрывается. 

В случае, если данный контейнер содержит более одной линейной структуры данных, каждая последующая структура конкатенируется с данной в одну строку.

== "Отключение" контекста служебных символов ==

В случае, если данный символ представляет собой некоторый значимый для синтаксического анализатора служебный символ, его контекст можно "отключить" путём указания перед ним деконтекстного символа "*\*". После этого во время обработки исходного кода анализатором, смысл символа будет трактован как обычное символьное значения, при этом в результирующей строке символ первый "*\*" ("*\a*" => "*a*", "*\\a*"=>"*\a*") будет удалён.  