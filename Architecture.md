### This story in English: [Read](Architecture_Eng.md) ###

# Описание #

В данной статье описываются основные подходы к организации внутренней
архитектуры системы:
  1. Подход к структурной реализации движка
  1. Базисная единица движка системы - "**Пакет**"
  1. Организация и управление пакетами
  1. Подходы к расширяемости и обновлениям


# Подробности #

## Структурная реализация движка ##

Основная задача, которая ставилась на движок, во время его разработкм,
заключалась в высоком уровне его гибкости и комфортности для разработчиков
при портировании сторонних решений в систему.
В этом контексте очень высокий приоритет был отдан спецификации и стандартизации
протоколов взаимодействия пакетов, а так же обеспечению пользоваля функциямя управления
данными пакетами.

Для лучшего понимая функционирования и структурной части движка стоит рассмотреть
дерево каталого, из которых состоит базисный движок:

```
-/
 -- config.xml            ; Main kernel settings
 -- install.php           ; System installation script
 -- index.php             ; System startpoint
 -- sl.php (PROPOUSED: admin.php)    ; Administration UI
 -- upart.php             ; Client(foreign visitor) UI
 -- dx.php                ; Ajax methods caller 
 -- lib                   ; InvisCMS Engine   
 -- core                  ; System branches
     -- abstractions      ; Packages abstractions
       -- defaultpackage    
         -- def.php     
     -- interfaces        ; Packages interfaces
       -- defaultpackage
         -- def.php
     -- errors            ; Packages errors definitions
       -- defaultpackage
         -- def.php
     -- packages          ; Packages mainclasses
       -- defaultpackage
         -- init.php (+)   ; File with baseclass implementation
         -- config.xml (*) ; Some common configuration, which uses in package context (OPTIONAL)
         -- info.xml (+)   ; Information about package
         -- dependings.xml (+) ; Dependings information
         -- license.xml (*); File with license bode (OPTIONAL)
     -- others (PROPOUSED: `libs`) ; Others librariries (NOT PACKAGES)
       -- init.php         ; "Magic" script what provide linking of all packages
       -- globals.php      ; Some basic helpful functions  
   -- jscore               ; System javascript core
     -- basecore           ; Base javascript core functions
       -- jallib           ; JavascriptActiveLibraries root directory
         -- defaultlib
           -- functions.jal  ; JAL package implementation
     -- thirdpart          ; Thirdpart javascript packages
   -- skins                ; System templates and styles
    -- default             
      -- styles
   -- temp                 ; Directory to save different temprorary informations and files
     -- uploads            ; Uploaded by visitors files
     -- logs               ; System events history
     -- files              ; Files uploaded from administration part
     -- backups            ; Backup of some system data (Example: Article changes hronology, clients base)
   -- modules              ; Modules packages
     -- admin              ; Admin-part modules
       -- defaultmodule
         -- actions        ; Actions for client-side events (what was excepted by POST)
         -- forms          ; 
           -- main.frm(+)     ; Module start-point (this script will be automaticle called, when will requested by system)
           -- config.xml (+)    ; Module common configuration settings
           -- info.xml(+)       ; Information(authority) about this module
           -- license.xml(*)    ; License information
           -- dependings.xml(+) ; Package dependings information
     -- client
```

Как можно заметить изучив структуру директорий, единица "**Пакет**" делится на несколько логических частей, которые в совокупности представляют целостный объект "**Пакета**".
Во время запроса на подключение пакета к системе, изначально будет обработан файл **dependings.xml**, который имеет следующую структуру:

```
<?xml version='1.0' encodings='utf-8'?>
<data>
  <item type='(abstraction|package|errors|interface|lib)' value='{%dependense_identifier%}'/>
  ....
</data>
```

В случае запроса пакета (параметр `*type*` в значении `*package*`) то будет произведена попытка подключить зависимый пакет (если он зарегистрирован в системе), после чего обработка будет передана обратно.
В случае, если обработка зависимостей не была успешно, то данный факт добавляется в историю, а система генерирует соответствующее исключение.

Для лучшей организации пакетов, в системе существует **Индекс**(репозиторий) пакетов, в котором сохраняется информация о всех доступных на данный момент пакетах.

Репозиторий обновляется в момент загрузки нового пакета, либо обновлении одного из уже зарегистрированных. Структура объекта "**Репозитрий**" в большей степени наследует с-ва объекта "**Пакет**", и может быть представлена в следующем виде:

```
Пакет:{
  Стаус: ("Включён","Выключен"),
  Идентификатор,
  Название,
  Зависимости: [{Тип_1:Идентификатор_1},...,{Тип_N:Идентификатор_N}],
  Версия,
  ДатаПубликации,
  Автор,
  ТипЛицензии,
  АдресЛицензии
};
```

В базовую поставку системы входят следующие базисные пакеты, которые обеспечивают работоспособность системы, и подключаются в любом случае: **system**, **modules**, **database**, **errors**.

Говоря о пакетах, нельзя не вспомнить о таком вопросе, как приложения 3-их поставщиков, по отношению к которым выдвигаются следующие требования:
  1. Удовлетворение спецификации пакетов
  1. Отсутствие опасности для пользователя
  1. Поддержка текущей версии платформы
  1. Достоверность поставляемой информации

Для этого предлагаются следующие меры:
  1. Возможность регистрации разработчиками своих пакетов на стороне сервера разработчика **InvisibleCore** и безоплатная сертификация пакетов с присвоением им регистрационного ключа, по которому будет создана запись на стороне сервера разработчика системы, в которой будет хранится информация, которая будет в дальнейшем идентифицировать поставщика и его продукт.
  1. Предоставить пользователям возможность перед установкой пакета в систему передать некоторую информацию о нём (включая поставляемый вместе с ним ключ-идентификатор), для потверждения аутентичности пакета, и его безопасности.

Для обеспечения возможности расширения числа поставляемых в базовой поставке пакетов, решениями сторонник поставщиков, в системе присутствуют следующие возможности:

  * Система управления обновлениями
    * Пакет ` *PatchController* `
    * Запрос обновлений отправляется на сервер компании-поставщика пакетов по **HTTP** протоколу, в отклик на что, если обновление существует, передаётся **XML**-совместимый документ с указанием даты релиза, версии релиза и списком изменений
    * Обязательным является инсталляция на стороне компании-поставщика шлюза для обработки запросов на обновление (**API**-интерфейс "**Система обновлений**")
  * Система установки и запроса новых пакетов
    * Пакет `*extending*`
    * Запрос новых пакетов направляется на сервер разработчика системы по протоколу HTTP, в качестве отклика на который, передаётся **XML**-совместимый список доступных для загрузки пакетов (передаваемые поля соответствуют спецификации объекта "**Пакет**")

### Подключение пакетов ###

На данном этапе, происходит автоматическое подключение, и создание экземпляров каждого размещённого в регистре пакетов (**директории**) пакета автоматически во время запуска основного скрипта. Однако в будующей версии предполагается подключать лишь запрашиваемые текущим модулем пакеты (не включая списка базисных пакетов), что должно значительно уменьшить время обработки и загрузку системы.

Ещё одна проблема текущей версии системы связана с обработкой информационных файлов пакетов. Так как репозиторий пакетов (иначе говоря хеш всех пакетов) ещё до конца не был введён, на данном этапе система не подключает пакеты основываясь на данных из БД, а каждый раз производит обработку поставляемых с пакетом XML данных, что в значительной мере сказывается на уровне нагрузки на сервер.

Для подключения пакетов используется приложение `/lib/core/others/init.php`, который производит обработку списка доступных на данный момент пакетов, и при успешной их обработке подключает в глобальную среду.

_Предложено позволять разработчикам указывать возможность создания дополнительных экземпляров объекта пакета, помимо экземпляра глобальной среды, что должно указываться в конфигурационном файле в качестве параметра `instances_allow`, который может приобретать значения `yes` либо `no`._

Особенным пакетом является пакет `system`, который не подключяется по стандартной схеме, а подключается напряму к документу init.php, при чём количество экземпляров данного пакета не может быть более одного. Это совершается по тем причинам, что именно данный пакет и содержит функции для осуществления подключения других пакетов.

Объект "Система" поставляет следующие публичные методы:

```
interface system
{
  /**
  * @return bool
  **/
  public function registerPackage($indentifier);
  
  /**
  * @return bool
  **/
  public function loadLibs();
  
  /**
  * @return bool
  **/
  public function autoLoad($mode="auto");

  /**
  * @return bool
  **/
  public function loadOneLib($identifier);
}

```

## Расширяемость в контексте организации модульной структуры ##

На уровень выше пакетов в дереве абстракции находится объект "Модуль", который на прямую основн на объекте "Пакет", а то есть использует его функциональную базу.

Поставка модуля имеет следующие обязательные компоненты:

-- default\_module
> -- actions
> > -- main.inc

> -- forms
> > -- main.frm

> -- config.xml
> -- info.xml
> -- license.xml
> -- dependings.xml

При запросе модуля для подключения системой, будет запрошен файл main.frm, который будет подключён в контексте модуля `modules` по-методу функции 'eval()`. При этом в локальную среду методы modules::loadModule() включаются все текущие подключённые экземпляры пакетов, в то же время каждый модуль наследует $this-среду класса modules, и наследуемых (явным образом) им других классов.

Обработка событий форм, которые необходимо обработать в контексте одной из составляющих модуля, происходит следующим образом:
  * В качестве одного из элементов формы поставляется элемент с именем: `*action_{%event%}*`
  * Каждому имени **{%event^}** должен соответствовать файл **{%event%}.inc**, директории ./actions, в котором будет находится необходимая логика для обработки формы.

Объект ` *Модуль* ` имеет следующее представление:
```
   Модуль:{
     Статус: ('включён','выключен'),
     Идентификатор,
     Имя,
     События: [{'идентификатор_1':'название_1'},...,{'идентификатор_1':'название_1'}],
     Зависимости,
     Автор,
     Версия,
     ДатаРелиза
   } 
```

Во время подключения каждого модуля, так же автоматически отрисовывается навигационное меню, которое позволяет пользователю совершать переходы внутри контекста каждого отдельного модуля, и в качестве тексте ссылка берёт название события, а в качестве идентификатора раздела модуля - идентификатор события.

Пример:
http://host.domen/admin/module1/main(/args)*

В данном случае будет подключён раздел `main` (main.frm) модуля `module1`. Так же возможно указывать некоторые опциональные параметры модулю, однако в текущей версии систему за их обработку отвечает исключительно внутренняя реализация модуля, которая имеет доступ к глобальному объекту переменных изъятых из базового URI, из которого и может брать необходимые данные.

Так как система изначально использует систему ЧПА (человеко-понятных адресов), основанную на поставляемой сервером Apache технологии ModRewrite, появляется вопрос: "В каком случае запрашивать модуль, а в каком передать управление некоторым модулям системы?".

Данная проблема наиболее ярко выражается в случае с запросом к админ части (нам ведь нужно именно изменение контекстов, а не запрос модуля `admin`), либо при обращении к страницами по короткому адресу, либо их идентификатору (возможность чего так же поставляется в базисном варианте системы).

По этой причине в систему существуют исключительные ситуации обработки адресов.

Исключительная ситуация обработки адреса - ситуация, при которой идентификатор представляет ключевое слово в системе, либо зарезервированный адрес.

Для обработки исключительных ситуаций система проверяет идентификатор первого уровня вложенности, по отношению к корневому URI ('/'), и если это зарезервированное слово, производит соответствующие действия, либо подключает модуль.

В случае спорной ситуации между модулем и зарезервированным адресом (перекрытие первого последним, либо наоборот), то приоритет отдаётся модулю. То есть сначала производится проверка возможности подключения некоторого модуля с соответствующим идентификатором, после чего управление передаётся либо модулю, в зависимости от успешности проверки, либо следующей условной конструкции, для поиска возможных зарезервированных адресов. В случае, если все проверки завершились неудачно, то подключается модуль с идентификатором `default`.

Как и в случае с пакетами, модули организованны ввиде индекса (репозитория) модулей, который наследует все с-ва объекта "Модуль", при этом дополняется св-ом `ПрофилиДоступа'.
```
Модуль:{
...
ПрофилиДоступа: ['Идентификатор1',...,'ИдентификаторN']
}
```

Идентификатору профиля доступа соответствует экземпляр объекта "ПрофильДоступа" (см. Политика разграничения прав), и во время запроса на подключение данного модуля в первую очередь проверяется вхождения пользователя в группу, идентификатор профиля доступа, назначенный которой, соответствует идентификатору из массива ПрофилиДоступа данного модуля.








